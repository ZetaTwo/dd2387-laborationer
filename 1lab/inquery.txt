0.1  MAKE IT HAPPEN
--------------------------------------------------------------------------------
:::: What does `$*` mean inside a makefile?
--------------------------------------------------------------------------------

Answer: The stem that matches an implicit pattern. Example:

test_%_run: test_%.cpp
    echo $*

$ touch test_foo.cpp && make test_foo_run # 'foo' printed
$ mkdir bar && touch bar/test_foobar.cpp && make test_foobar_run # 'bar/foobar' printed

--------------------------------------------------------------------------------
:::: What is the purpose of `-Wall` and -g, when passed as arguments to g++?
--------------------------------------------------------------------------------

Answer:

- Wall: Enable (almost) all warnings
- g: Include debug information in output program (mainly for GDB)

--------------------------------------------------------------------------------
:::: What is the difference between an object file, and an executable?
--------------------------------------------------------------------------------

Answer:

An object file is a precompiled "library" that you can link to when compiling
other things. An executable is an entry point for processes. While an executable
is a series of instructions to execute in a process, an object file is more like
a toolbox containing functions and other definitions for use by executables.

--------------------------------------------------------------------------------





0.2  HELLO WORLD
-------------------------------------------------------------------------------
:::: What is the purpose of `std::cout`, `std::cerr`, and `std::clog`,
     respectively?
-------------------------------------------------------------------------------

Answer:

- cout is a stream that prints output to standard output (typically the terminal
  the program is invoked from). It is meant for the main output from a program.
  For instance, a program that copies files might print progress information to
  cout.
- cerr is a stream that prints to standard error (also typically the terminal
  the program is invoked from). It is meant for error output, for instance a
  program that copies files might print warnings and error information such as
  permission issues to cerr.
- clog is meant for log output, and is by default connected to standard error.
  For instance, a program might print fine-grained debugging information to
  clog.

-------------------------------------------------------------------------------




0.3  TRAIN SPOTTING

    int powerof (int x, int y) {
      int res = 1;

      for (int i = 0; i < y; ++i);
        res *= x;

      return res;
    }

    int main () {
      int const a = 2;
      int const b = 4;

      int   x = powerof(a, b);
      float y = 3.1415;

      std::cout << a << "^" << b << " = " << x << ";\n";

      if (y == 3.1415)
        std::cout << y << " is equal to 3.1415!\n";
      else
        std::cout << y << " is not equal to 3.1415!\n";
    }

--------------------------------------------------------------------------------
:::: Why does not `powerof` return the expected value (16), when invoked with 2 and 4?
--------------------------------------------------------------------------------

Answer:

The for statement is immediately followed by a semicolon (;) and not a code
block, which means the following row is not in the loop body and is therefore
executed exactly once.

--------------------------------------------------------------------------------
:::: Why does not `y` compare equal to 3.1415?
--------------------------------------------------------------------------------

Answer:

Because floating-point numbers are not meant to be compared for exact equality.
It might in fact not be possible to save the exact value of a given literal as a
float (or double), and so an approximation is used instead. Of course, comparing
approximate values for equality is rather futile.

--------------------------------------------------------------------------------
:::: Is there any difference in behavior if we compare `y` to 3.1415f, if so: why?
--------------------------------------------------------------------------------

Answer:

Yes; because the 3.1415 is a double literal while 3.1415f is a float literal. In
the latter case the two expressions (y and 3.1415f) evaluate to equal values.

--------------------------------------------------------------------------------
:::: What is the recommended method to use when trying to determine if
:::: two floating-point values are equal, and why?
--------------------------------------------------------------------------------

Answer:

Check if the difference between them is smaller than some small value; Because
it is extremely unlikely that two values will be the same even if algebra says
they should be (because only a finite subset of the rational numbers can be
represented exactly).

--------------------------------------------------------------------------------


0.4 DOES IT FIT

int count_if_followed_by (char const * p, int len, char a, char b) {
  int        count = 0;
  char const * end = p + len;

  while (p != end) {
    if (*p == a && *(p+1) == b)
      count += 1;

    ++p;
  }

--------------------------------------------------------------------------------
:::: Why is it important to test the boundary conditions of an implementation,
     especially in the case of `count_if_followed_by`?
--------------------------------------------------------------------------------

Answer:

- Errors often happen at the boundaries if you're careless
- Sometimes errors are more easily exposed at the boundaries even when they
  affect program flow elsewhere as well (and so, testing boundary conditions can
  help expose problems that may not be apparent otherwise).
- Especially in the case of count_if_followed_by because it does pointer
  arithmetic, which doesn't necessarily cause compile-time errors nor runtime
  crashes.

--------------------------------------------------------------------------------



0.5 WILL IT FLOAT (birth.cpp)

class A {
public:
   A () {
     std::cout << "default-constructor" << std::endl;
   }

   A (A const& src) {
     std::cout << "copy-constructor" << std::endl;
   }

  ~A () {
    std::cout << "destructor" << std::endl;
  }

   A(char const* s) {
      std::cout << "some other constructor" << std::endl;
   }

   A& operator= (A const& src) {
     std::cout << "the assignment operator" << std::endl;
     return *this;
   }
};

void no_ref(A a) {}
void with_ref(const A & a) {}

int main()
{
    A a("my name is a");

    A b = a;          // what is the difference
    A c(a);           // between these three
    A d;              // forms of initialization?

    d = a;

      no_ref (a);     // will this copy the value of `a`?
    with_ref (a);     // will this copy the value of `a`?

    A *aa = new A[5];
    delete aa;        // what will happen?
    return 0;
}

--------------------------------------------------------------------------------
:::: valgrind indicates that there is something wrong with birth.cpp; what, and
:::: why?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
:::: What will happen if we try to free a dynamically allocated array
:::: through `delete p` instead of `delete [] p`?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------


0.5 WILL IT FLOAT (birth.cpp)

class A {
public:
   A () {
     std::cout << "default-constructor" << std::endl;
   }

   A (A const& src) {
     std::cout << "copy-constructor" << std::endl;
   }

  ~A () {
    std::cout << "destructor" << std::endl;
  }

   A(char const* s) {
      std::cout << "some other constructor" << std::endl;
   }

   A& operator= (A const& src) {
     std::cout << "the assignment operator" << std::endl;
     return *this;
   }
};

void no_ref(A a) {}
void with_ref(const A & a) {}

int main()
{
    A a("my name is a");

    A b = a;          // what is the difference
    A c(a);           // between these three
    A d;              // forms of initialization?

    d = a;

      no_ref (a);     // will this copy the value of `a`?
    with_ref (a);     // will this copy the value of `a`?

    A *aa = new A[5];
    delete aa;        // what will happen?
    return 0;
}


--------------------------------------------------------------------------------
:::: valgrind indicates that the program suffers from a few problems, which and
:::: why?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------
:::: If you uncomment the entire if-block in foo, is there any difference in how much
:::: memory that is leaked?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------
:::: If you change the last line of `main` to the following; why does
:::: valgrind still issue diagnostics related to memory management?
::::
:::: Data ** p = foo (v, size);
:::: delete [] p;
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------



0.6  THE SIMPLE CONTAINER
--------------------------------------------------------------------------------
:::: `operator[]` must in some cases be marked as `const`, but not always; when,
:::: and why?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------
:::: The semantics of copying a UIntVector might not be trivial; why must we
:::: manually implement the relevant code, instead of having the compiler generate
:::: it for us?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------



0.7  THE TEMPLATE VECTOR
--------------------------------------------------------------------------------
:::: Iterating over a range of elements can be done with a range-based for-loop,
:::: but the type of `source` must meet certain requirements; what are they?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------
:::: The C++ Standard sometimes state that a type in the Standard Library is
:::: "unspecified"; why do you think that is?
--------------------------------------------------------------------------------

Answer: ...

--------------------------------------------------------------------------------
