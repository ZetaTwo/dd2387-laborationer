/////////////////////////////////////////////////////////////////
//
// Personuppgifter (namn, pnr, epost) på dem som gjort labben
//


/////////////////////////////////////////////////////////////////
//
// 1.1
//
// vad betyder \$* i en makefile?


// vad gör -Wall och -g ?


/////////////////////////////////////////////////////////////////
//
// 1.2 a)
//
// int powerof(int x, int y) {
//     int res = 1;
//     for (int i = 0; i < y; i++); {
//         res *= x;
//     }
//     return res;
// }
//
// int main() {
//     int x = 10;
//     int y = 3;
//
//     int res = powerof(x, y);
//
//     std::cout << x << " upphöjt till " << y << " är " << res << std::endl;
//
//     float z = 0.29;
//     int w = (int) (z * x * x);
//     if (z * x * x == 29)
//         std::cout << z << "*" << x * x << " är 29" << std::endl;
//     else
//         std::cout << z << "*" << x * x << " är inte 29" << std::endl;
// }
//
// Varför blir värdet på variabeln w inte det man tror (0.29*100)?


// Hur många varv körs for-loopen i funktionen powerof?


// 1.2 b)
//
// int must_follow_a(char * start, int length, char a, char b) {
//     int nr = 0;
//     for (int i = 0; i < length; i++, ++start) {
//         if (*start == a && *(start + 1) == b) // maintainers note: DANGER!
//             nr += 1;
//     }
//     return nr;
// }
//
// Dina tre testfall


// Varför är det så viktigt att testa randvillkoren?


/////////////////////////////////////////////////////////////////
//
// 1.3
//
// Bifoga källkoden till din version av A.cpp


// Vad skriver ditt program ut, var förberedd att förklara varför.


// När frigörs objekten?


// När skapas temporära objekt?

//   A b = a;         // vad är skillnaden
//   A c(a);          // mellan dessa
//   A d;             // tre tekniker?


//   no_ref(a);       // Bildas temporära objekt?


//   with_ref(a);     // Bildas temporära objekt?


//   delete aa;       // Vad kommer att hända


/////////////////////////////////////////////////////////////////
//
// struct Data {
//     int x, y, z;
// };
//
// Data ** foo(Data ** v, int x) {
//     for (int i = 0; i < x; i++)
//         //if (v[i] != 0)
//             v[i] = new Data;
//     return v;
// }
//
// int main () {
//     const int size = 5;
//     Data ** v = new Data * [size];
//     Data ** p = foo(v, size);
//     delete [] p;
// }

// Hur ser valgrinds felmeddelande ut?


// Blir det någon skillnad i hur mycket minne som läcker när man
// kommenterar if-satsen?


// Borde det ha blivit någon skillnad?


// Varför läcker programmet fortfarande minne?


/////////////////////////////////////////////////////////////////
//
// 1.4
//
// Generellt är det ofta en god idé att låta konstruktorer som
// tar ett argument deklareras som explicit. Varför? Ange ett
// exempel där det annars kan bli dumt.

Annars kan buggar orsakar av att parametrar implicit castas till andra typer.
Om vi har en klass A med en konstruktor A(int b) och en funktion C med två signaturer, C(int d) och C(const A& e)
och vi anropar C(3) så kan det bli att vi anropar C(A(3)), dvs den andra varianten istället för den första.
Med explicit kan inte detta hända

// operatorn[] måste vara en konstant medlemsfunktion i vissa
// fall. När och varför? Hur kopierar man vektorn?

Operatorn[] måste returnera olika typer när man arbetar med en const resp icke-const Vector.
När Vectorn inte är const ska en referens lämnas så att man kan göra tilldelningar till element, t.ex.: a[1] = 2;
Nät Vectorn är const så ska det förgående exemplet inte fungera men man måste fortfarande kunna läsa elementen, t.ex.: int a = b[1];
Därför måste detta inte returnera en referens och vi behöver två olika versioner av operatorn.